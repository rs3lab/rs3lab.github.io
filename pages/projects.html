<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Projects - RS3Lab</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="../pages/projects.html">

        <meta name="author" content="RS3Lab" />
        <meta name="description" content="Below are some projects that our group is actively working on. If you are a Ph.D. student, email Sanidhya. Our group also has some specific semester and optional projects for students at EPFL. Transient Operating System Design The main goal of this big project is to dynamically modify various …" />

    <meta property="og:site_name" content="RS3Lab" />
    <meta property="og:type" content="article"/>
    <meta property="og:title" content="Projects"/>
    <meta property="og:url" content="../pages/projects.html"/>
    <meta property="og:description" content="Below are some projects that our group is actively working on. If you are a Ph.D. student, email Sanidhya. Our group also has some specific semester and optional projects for students at EPFL. Transient Operating System Design The main goal of this big project is to dynamically modify various …" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="../theme/css/bootstrap.rs3lab.min.css" type="text/css"/>
    <link href="../theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="../theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="../theme/css/style.css" type="text/css"/>
        <link href="../assets/css/rs3lab.css?1764166048.9938426" rel="stylesheet">



</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="../" class="navbar-brand">
RS3Lab            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="../pages/team.html">
                             Team
                          </a></li>
                         <li class="active"><a href="../pages/projects.html">
                             Projects
                          </a></li>
                         <li><a href="../pages/publications.html">
                             Publications
                          </a></li>
                         <li><a href="../pages/about.html">
                             About
                          </a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content" class="body">
        <h1 class="entry-title">Projects</h1>
        
        <div class="entry-content">
            <p>Below are some projects that our group is actively working on. If you are a
<strong>Ph.D.</strong> student, email <a class="reference external" href="mailto:sanidhya.kashyap&#64;epfl.ch">Sanidhya</a>.</p>
<p>Our group also has some specific semester and optional projects for students at
EPFL.</p>
<div class="section" id="transient-operating-system-design">
<h2>Transient Operating System Design</h2>
<p>The main goal of this big project is to dynamically modify various subsystems to
cater to heterogeneous hardware and varying application requirements.  Most of
the prior works focus on IO, while our focus is mostly on the concurrency
aspect. In particular, we are exploring how applications can fine-tune the
concurrency control mechanisms and underlying stack to improve their
performance. Some of the projects are as follows:</p>
<ol class="arabic simple">
<li>A concurrency control runtime to efficiently switch between locks at various
granularity.</li>
<li>New low-level language to support lock design while ensuring lock
properties, such as mutual exclusion, starvation avoidance, and fairness.</li>
<li>A lightweight hypervisor that caters to various forms of virtualization:
bare-metal to serverless.</li>
<li>Re-architecting OS for microsecond IO.</li>
</ol>
<p>We will further extend this project to reason about data structures' concurrency
and consistency.</p>
</div>
<div class="section" id="scalable-storage-stack">
<h2>Scalable Storage Stack</h2>
<p>With blazing fast IO devices, saturating them is becoming a difficult task.
Unfortunately, the current OS stack is the major bottleneck that is still
operating in the era of 2000s. As a part of this big project, we are looking at
ways to redesign the OS stack to support fast storage devices. We are working
on designing new ways to improves the design of file systems. Some of the
projects are as follows:</p>
<ol class="arabic simple">
<li>Designing new techniques to saturate and scale operations
for various storage media.</li>
<li>Understanding the implication of storage class memory over
traditional storage media, such as SSDs.</li>
<li>Designing new storage engines for upcoming storage media,
such as ZNS SSDs.</li>
<li>Offloading file system stack to computational SSDs.</li>
</ol>
</div>
<div class="section" id="concurrency-primitives-and-frameworks">
<h2>Concurrency Primitives and Frameworks</h2>
<p>With our particular interest in designing new synchronization primitives and
concurrency frameworks, we are looking at designing new primitives that further
squeeze the performance out of hardware for two scenarios: heterogeneous
hardware (such as BIG/Little architectures and high bandwidth memory) and
rack-scale systems. We are revisiting some of the primitives and trying to
reason about their practicality. Some of the ongoing projects are as follows:</p>
<ol class="arabic simple">
<li>Revisiting the design of locking primitives for very large multicore
machines.</li>
<li>Redesigning concurrency primitives for microsecond scale
application in a rack scale environment.</li>
<li>Reasoning about various bugs in a concurrent environment.</li>
</ol>
</div>
<hr class="docutils" />
<div class="section" id="projects-for-bachelors-and-masters-students">
<h2>Projects for Bachelors and Masters students</h2>
<div class="section" id="performance-ebpf-performance-modeling-of-ebpf-programs-tao-lyu">
<h3>[Performance/eBPF] Performance Modeling of eBPF Programs (Tao Lyu)</h3>
<p>eBPF enables 1) customizing the policies of kernel subsystems
(e.g., scheduling policy, page eviction policy) and
2) offloading application logic to the kernel as a fast path.
In both scenarios, eBPF programs (also known as kernel extensions)
reside at the performance-critical paths.
Therefore, they should be as performant as possible.
Otherwise, eBPF programs can be counterproductive:
instead of improving kernel performance, they actually degrade it.</p>
<p>Unfortunately, performance issues are common because
(1) eBPF applications are updated frequently,
often without rigorous performance review, making them more error-prone;
and (2) many eBPF developers aren’t kernel experts and lack familiarity
with the performance characteristics and micro-optimizations of hot kernel paths.
Unlike safety, which the eBPF verifier forcefully guarantees,
the ecosystem overlooks this equally important concern:
performance due to the overshadowed of the focus on safety.</p>
<p>In this project, we call on the community to
also focus on the performance clarity of eBPF programs.
Ideally, in this project, we aim to design a scalable and
accurate performance model for eBPF programs.
This model, acting as a building block,
can further be utilized in various use cases, including:</p>
<ul class="simple">
<li>Performance quantification: Quantify the performance of each line of programs with explanations to help people understand their performance.</li>
<li>Performance debugging: based on the performance quantification, either manually or semi-automatically adjust programs to achieve better performance.</li>
<li>Performance check: Check the new program’s performance against that of functionally equivalent baselines, serving as oracles. This performance check is optional for developers, rather than being mandatory like the safety verification.</li>
</ul>
<p>Targeting students who want to do a thesis or long-term research.</p>
</div>
<div class="section" id="memory-management-memory-allocators-in-tiered-memory-musa-unal">
<h3>[Memory Management] Memory allocators in tiered memory (Musa Unal)</h3>
<p>Memory management is a critical component of operating systems.
Modern data centers rely on different types of memory (with different latency and bandwidth) to manage data,
which is also referred as tiered memory.
This project aims to understand how profiling can help identify optimal allocation sites in tiered memory.</p>
<p>In this project, you will:</p>
<ul class="simple">
<li>Learn how PGO (Profile-guided optimization) can help an application to improve it's performance.</li>
<li>Learn how memory allocators works and manage the data.</li>
<li>Understand how CXL (Compute Express Link) works.</li>
</ul>
<p>Prerequisite:</p>
<ul class="simple">
<li>Have a basic understanding of how operating systems work.</li>
<li>Understanding C/C++</li>
</ul>
<p>References:</p>
<ul class="simple">
<li><a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3582016.3582063">https://dl.acm.org/doi/abs/10.1145/3582016.3582063</a></li>
<li><a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/3600006.3613157">https://dl.acm.org/doi/pdf/10.1145/3600006.3613157</a></li>
<li><a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/3461648.3463844">https://dl.acm.org/doi/pdf/10.1145/3461648.3463844</a></li>
</ul>
</div>
<div class="section" id="memory-management-energy-consumption-in-tiered-memory-musa-unal">
<h3>[Memory Management] Energy consumption in tiered memory (Musa Unal)</h3>
<p>Memory management is a critical component of operating systems.
Modern data centers rely on different types of memory (with different latency and bandwidth) to manage data,
which is also referred as tiered memory.
This project aims to understand the trade-offs between energy consumption and performance
in tiered memory.</p>
<p>In this project, you will:</p>
<ul class="simple">
<li>How Linux's memory tiering system works.</li>
<li>Understand how to measure energy consumption in memory tiering.</li>
<li>Understand how CXL (Compute Express Link) works.</li>
</ul>
<p>Prerequisite:</p>
<ul class="simple">
<li>Have a basic understanding of how operating systems work.</li>
<li>Understanding C/C++</li>
</ul>
<p>References:</p>
<ul class="simple">
<li><a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3582016.3582063">https://dl.acm.org/doi/abs/10.1145/3582016.3582063</a></li>
<li><a class="reference external" href="https://docs.kernel.org/scheduler/sched-energy.html">https://docs.kernel.org/scheduler/sched-energy.html</a></li>
</ul>
</div>
<div class="section" id="scalable-os-linux-kernel-data-structure-switching-vishal-gupta">
<h3>[Scalable OS] Linux Kernel Data Structure Switching (Vishal Gupta)</h3>
<p>The Linux kernel uses multiple data structures across different subsystems to store data.
This includes linked list, hash table, red-black tree and maple tree.
However, based on different access patterns these data structures might not be optimal.</p>
<p>In this project, you will:</p>
<ul class="simple">
<li>Implement mechanisms to switch between different kernel data structures.</li>
<li>Implement policies to decide when to switch.</li>
</ul>
<p>Prerequisite: Understanding of kernel data structures.</p>
<ul class="simple">
<li>Linked list:   <a class="reference external" href="https://github.com/torvalds/linux/tree/master/include/linux/list.h">https://github.com/torvalds/linux/tree/master/include/linux/list.h</a></li>
<li>Hash Table: <a class="reference external" href="https://github.com/torvalds/linux/tree/master/include/linux/hashtable.h">https://github.com/torvalds/linux/tree/master/include/linux/hashtable.h</a></li>
<li>Red-Black Tree: <a class="reference external" href="https://github.com/torvalds/linux/tree/master/include/linux/rbtree.h">https://github.com/torvalds/linux/tree/master/include/linux/rbtree.h</a></li>
<li>Maple Tree: <a class="reference external" href="https://github.com/torvalds/linux/tree/master/include/linux/maple_tree.h">https://github.com/torvalds/linux/tree/master/include/linux/maple_tree.h</a></li>
</ul>
</div>
<div class="section" id="scalable-os-faster-uprobes-using-user-mode-ebpf-kumar-kartikeya-dwivedi">
<h3>[Scalable OS] Faster Uprobes using User Mode eBPF  (Kumar Kartikeya Dwivedi)</h3>
<p>BPF based tracing is used to execute programs and collect data when certain
functions are triggered in the kernel. The same is possible in user space using
the ‘user probes’ feature, where programs are executed when USDT probes are
triggered within the user space applications. However, currently the
implementation of uprobes requires trapping in to the kernel whenever an event
occurs, leading to slowdowns in applications, and being up to 2x slower than
system call context switches. This project explores whether the inception of a
new ‘user mode eBPF’ mode and making uprobes execute such program types in user
space will be faster and have the same level of usability. The ideal end goal
would be to attain transparent 100% compatibility with the current uprobe
mechanism.</p>
<p>In this project, you will:</p>
<ul class="simple">
<li>Develop a deep understanding of the eBPF verifier’s static analysis process.</li>
<li>Create a new ‘user mode eBPF’ program type for eBPF.</li>
<li>Measure and benchmark usability and performance differences between the
current uprobe mechanism and the one based on user mode eBPF.</li>
</ul>
<p>Prerequisite:</p>
<ul class="simple">
<li>A basic level of understanding of eBPF.</li>
<li>Proficiency in C and Python.</li>
</ul>
<p>References:</p>
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/753601">https://lwn.net/Articles/753601</a></li>
<li><a class="reference external" href="https://lore.kernel.org/bpf/20211116013041.4072571-1-andrii&#64;kernel.org">https://lore.kernel.org/bpf/20211116013041.4072571-1-andrii&#64;kernel.org</a></li>
<li><a class="reference external" href="https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html">https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html</a></li>
</ul>
</div>
<div class="section" id="systems-for-ml-improving-the-performance-of-ml-workloads-yueyang-pan">
<h3>[Systems for ML] Improving the performance of ML workloads (Yueyang Pan)</h3>
<p>ML workloads are at the center stage of the 21st century computing evolution.
However, software that runs them is not entirely efficient. Thus, to efficiently
utilize current hardware, whether for inference or training, within a single
machine or across machines, we need to understand and redesign the current
software stack.</p>
<p>In this project, you will:</p>
<ul class="simple">
<li>Analyze and understand the overhead current software stack.</li>
<li>Do a complete breakdown of the cost associated within a single machine
and across machines for both inference and training.</li>
<li>Propose a set of optimizations that improves such systems performance.</li>
</ul>
<p>Prerequisite:</p>
<ul class="simple">
<li>Using existing ML software.</li>
<li>Basics about ML algorithms.</li>
</ul>
<p>You will learn:</p>
<ul class="simple">
<li>Understanding the performance of software systematically.</li>
</ul>
<hr class="docutils" />
<p>In case you have projects that are not mentioned above but fall under the
purview of our group's interest, feel free to contact us.</p>
</div>
</div>

        </div>
    </section>
        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="https://github.com/rs3lab" target="_blank">GitHub</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
           <i class="fa fa-home fa-lg"></i>
           <a href="https://www.epfl.ch/schools/ic/">School of Computer and Communication sciences (IC)</a>
           &middot;
           <a href="https://www.epfl.ch/en/">EPFL</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="../theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="../theme/js/respond.min.js"></script>


    <script src="../theme/js/bodypadding.js"></script>


</body>
</html>